#!/usr/bin/env node
"use strict";

const help = require('optimist')
.usage('Usage: $0 --host [host] --port [port] --user [user] --pass [pass] --db [db]')
.demand(['host', 'user', 'db'])
.describe('host', 'The hostname to the database you are connecting to')
.describe('port', 'The port number to connect to')
.describe('user', 'The MySQL user to authenticate as')
.describe('pass', 'The password for the MySQL user')
.describe('db', 'Name of the database to use for this db')

const argv = help.argv;
const MySQL = require('mysql');
const Promise = require('bluebird');

const db = MySQL.createPool({
	connectionLimit: 10,
	host: argv.host,
	port: argv.port || 3306,
	user: argv.user,
	password: argv.pass,
	database: argv.db,
	charset: 'utf8'
});

Promise.all([
	new Promise(resolve => {
		db.query('SELECT locale FROM craft_locales ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_globalsets', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, name, handle, type FROM craft_sections', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, sectionId, fieldLayoutId, name, handle, hasTitleField, titleLabel FROM craft_entrytypes ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_categorygroups', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldId, fieldLayoutId, name, handle FROM craft_matrixblocktypes ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_assetsources ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, type FROM craft_fieldlayouts', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, layoutId, fieldId, required FROM craft_fieldlayoutfields ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, name, handle, CONCAT("c.field_", handle) as "column", context, instructions, translatable, type, settings FROM craft_fields', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldId, fieldLayoutId FROM craft_supertableblocktypes', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
])
.spread((locales, globals, sections, types, categories, matrices, assets, layouts, layoutFields, fields, superTables) => {

	const models = [];
	const outputRecords = [];
	const outputModels = [];

	const fieldToType = (field) => {
		let type = null;
		let relation = null;
		let settings;
		try {
			settings = typeof field.settings === 'string' ? JSON.parse(field.settings) : field.settings;
			settings = settings || {};
		} catch (e) {}

		switch (field.type) {
			case 'ID':
				type = 'Type.String';
				break;

			case 'Groups':
				try {
					type = settings.limit === "" || settings.limit > 1 ? 'new Type.ListOf(UserGroup)' : 'UserGroup';
				} catch (e) {
					type = 'UserGroup';
				}
				relation = 'UserGroup';
				break;

			case 'Users':
				try {
					type = settings.limit === "" || settings.limit > 1 ? 'new Type.ListOf(User)' : 'User';
				}
				catch (e) {
					type = 'User';
				}
				relation = 'User';
				break;

			case 'Entries':
				try {
					if (settings.sources == '*') {
						type = 'Entry';
					}
					else if (settings.sources.length == 1) {
						let id = settings.sources[0].substr(8);
						let section = sections.filter(section => section.id == id)[0];
						type = `Entry${section.handle[0].toUpperCase() + section.handle.substr(1)}`;
					}
					else {
						type = field.handle[0].toUpperCase() + field.handle.substr(1) + `Entries`;
						if (models.indexOf(type) === -1) {
							models.push(type);
							outputModels.push(`class ${type} extends UnionModel {
	static get models () {
		return [${settings.sources.map(source => {
			const id = source.substr(8);
			const section = sections.filter(section => section.id == id)[0];
			return `Entry${section.handle[0].toUpperCase() + section.handle.substr(1)}`;
		}).join(', ')}];
	}
}

`);
							outputRecords.push(`domain.registerRecord(adapter, ${type}, {})`);
						}
					}
					type = settings.limit === "" || settings.limit > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {
					throw new Error(`Could not find entries for "${settings.sources}" : ${e.message}`);
				}
				relation = type;
				break;

			case 'Categories':
				try {
					let categoryId = settings.source.split(':')[1];
					let category = categories.filter(c => c.id == categoryId)[0];
					type = 'Category' + category.handle[0].toUpperCase() + category.handle.substr(1);
					relation = type;
					type = `new Type.ListOf(${type})`;
				}
				catch (e) {
					throw new Error(`Could not find category for "${settings.source}".`);
				}
				break;

			case 'Assets':
				try {
					if (settings.sources == '*') {
						type = 'Asset';
					}
					else if (settings.sources.length == 1) {
						let id = settings.sources[0].substr(7);
						let asset = assets.filter(asset => asset.id == id)[0];
						type = `Asset${asset.handle[0].toUpperCase() + asset.handle.substr(1)}`;
					}
					else {
						type = field.handle[0].toUpperCase() + field.handle.substr(1) + `Assets`;
						if (models.indexOf(type) === -1) {
							models.push(type);
							outputModels.push(`class ${type} extends UnionModel {
	static get models () {
		return [${settings.sources.map(source => {
			const id = source.substr(7);
			const asset = assets.filter(asset => asset.id == id)[0];
			return `Asset${asset.handle[0].toUpperCase() + asset.handle.substr(1)}`;
		}).join(', ')}];
	}
}

`);
							outputRecords.push(`domain.registerRecord(adapter, ${type}, {})`);
						}
					}
					type = settings.limit === "" || settings.limit > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {
					throw new Error(`Could not find asset for "${settings.source}" : ${e.message}`);
				}
				relation = type;
				break;

			case 'AssetFolders':
				type = 'AssetFolder';
				relation = 'AssetFolder';
				try {
					type = settings.limit == null || settings.limit > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			case 'Matrix':
				type = 'Matrix' + field.handle[0].toUpperCase() + field.handle.substr(1);
				relation = type;
				try {
					type = settings.maxBlocks == null || settings.maxBlocks > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			// TODO Tags
			// TODO Table

			case 'SuperTable':
				type = 'SuperTable' + field.handle[0].toUpperCase() + field.handle.substr(1);
				relation = type;
				try {
					type = settings.maxRows == null || settings.maxRows > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			case 'PlainText':
			case 'RichText':
			case 'Color':
			case 'Dropdown':
			case 'RadioButtons':
			case 'PositionSelect':
				type = 'Type.String';
				break;
			case 'MultiSelect':
				type = 'new Type.ListOf(Type.String)';
				break;
			case 'Lightswitch':
				type = 'Type.Boolean';
				break;
			case 'Number':
				type = 'Type.' + (settings.decimals == 0 ? 'Int' : 'Float');
				break;
			case 'Date':
				type = 'Type.Date';
				break;
			
			default:
				if (settings.columnType && settings.columnType == 'text') {
					type = 'Type.String';
					break;
				}
				throw new Error(`Unknown field type ${field.type}.`);
		}
		return { type, relation };
	};

	const fieldToDefinition = (field) => {
		let out = `${field.handle}: { `;
		let type = fieldToType(field).type;

		if (field.translatable == "1") {
			type = `new Type.Translatable(${type})`;
		}
		
		out += `type: ${type}, `;

		if (field.required) {
			out += `required: true, `;
		}

		if (field.name) {
			out += `label: ${JSON.stringify(field.name)}, `;
		}

		if (field.instructions) {
			out += `instructions: ${JSON.stringify(field.instructions)}, `;
		}

		return `${out} }`;
	};

	const fieldToRelationSelect = (field) => {
		switch (field.type) {
			case 'Assets':
			case 'Entries':
			case 'Categories':
				return `SELECT sourceId AS "id", "${field.handle}" AS "key", targetId AS "value" FROM craft_relations WHERE fieldId = ${field.id} AND sourceId IN (\${rowIds.join(', ')}) ORDER BY sortOrder`;

			case 'Matrix':
				return `SELECT ownerId AS "id", "${field.handle}" AS "key", id AS "value" FROM craft_matrixblocks WHERE fieldId = ${field.id} AND ownerId IN (\${rowIds.join(', ')}) ORDER BY sortOrder`

			case 'SuperTable':
				return `SELECT ownerId AS "id", "${field.handle}" AS "key", id AS "value" FROM craft_supertableblocks WHERE fieldId = ${field.id} AND ownerId IN (\${rowIds.join(', ')}) ORDER BY sortOrder`

			// case 'Users':
			// case 'Folders':

			// TODO Tags
			// TODO Table

			default:
				throw new Error(`Type ${field.type} is not a relation.`);
		}
	};

	const fieldToRelationInsert = (field) => {
		switch (field.type) {
			case 'Assets':
			case 'Entries':
			case 'Categories':
				return `
					sql.push(\`DELETE r FROM craft_relations AS r WHERE fieldId = ${field.id} AND sourceId = ?\`);
					values.push(data.id);
					if (data.${field.handle} && isArray(data.${field.handle}) === false) {
						sql.push(\`INSERT INTO craft_relations (fieldId, sourceId, sourceLocale, targetId, sortOrder, dateCreated, dateUpdated, uid) VALUES (${field.id}, ?, NULL, ?, ?, NOW(), NOW(), ?)\`);
						values.push(data.id, data.${field.handle}, 0, uuid4());
					}
					else if (data.${field.handle} && isArray(data.${field.handle}) && data.${field.handle}.length > 0) {
						sql.push(\`INSERT INTO craft_relations (fieldId, sourceId, sourceLocale, targetId, sortOrder, dateCreated, dateUpdated, uid) VALUES (\${data.${field.handle}.map(v => \`${field.id}, ?, NULL, ?, ?, NOW(), NOW(), ?\`).join('), (')})\`);
						data.${field.handle}.forEach((v, i) => {
							values.push(data.id, v, i, uuid4());
						});
					}
				`;

			case 'Matrix':
				return `
					if (data.${field.handle} && isArray(data.${field.handle}) === false) {
						sql.push(\`DELETE r FROM craft_matrixblocks AS r WHERE fieldId = ${field.id} AND ownerId = ? AND id != ?\`);
						values.push(data.id, data.${field.handle});
						sql.push(\`UPDATE craft_matrixblocks SET fieldId = ${field.id}, ownerId = ? WHERE id = ? LIMIT 1\`);
						values.push(data.id, data.${field.handle});
					}
					else if (data.${field.handle} && isArray(data.${field.handle}) && data.${field.handle}.length > 0) {
						sql.push(\`DELETE r FROM craft_matrixblocks AS r WHERE fieldId = ${field.id} AND ownerId = ? AND id NOT IN (?)\`);
						values.push(data.id, data.${field.handle});
						data.${field.handle}.forEach((v, i) => {
							sql.push(\`UPDATE craft_matrixblocks SET fieldId = ${field.id}, ownerId = ? WHERE id = ? LIMIT 1\`);
							values.push(data.id, v);
						});
					}
					else {
						sql.push(\`DELETE r FROM craft_matrixblocks AS r WHERE fieldId = ${field.id} AND ownerId = ?\`);
						values.push(data.id);
					}
				`;

			case 'SuperTable':
				return `
					if (data.${field.handle} && isArray(data.${field.handle}) === false) {
						sql.push(\`DELETE r FROM craft_supertableblocks AS r WHERE fieldId = ${field.id} AND ownerId = ? AND id != ?\`);
						values.push(data.id, data.${field.handle});
						sql.push(\`UPDATE craft_supertableblocks SET fieldId = ${field.id}, ownerId = ? WHERE id = ? LIMIT 1\`);
						values.push(data.id, data.${field.handle});
					}
					else if (data.${field.handle} && isArray(data.${field.handle}) && data.${field.handle}.length > 0) {
						sql.push(\`DELETE r FROM craft_supertableblocks AS r WHERE fieldId = ${field.id} AND ownerId = ? AND id NOT IN (?)\`);
						values.push(data.id, data.${field.handle});
						data.${field.handle}.forEach((v, i) => {
							sql.push(\`UPDATE craft_supertableblocks SET fieldId = ${field.id}, ownerId = ? WHERE id = ? LIMIT 1\`);
							values.push(data.id, v);
						});
					}
					else {
						sql.push(\`DELETE r FROM craft_supertableblocks AS r WHERE fieldId = ${field.id} AND ownerId = ?\`);
						values.push(data.id);
					}
				`;

			// case 'Users':
			// case 'Folders':

			// TODO Tags
			// TODO Table

			default:
				throw new Error(`Type ${field.type} is not a relation.`);
		}
	};

	const relationToProperty = (field) => {
		let single;
		let settings;
		try {
			settings = typeof field.settings === 'string' ? JSON.parse(field.settings) : field.settings;
			settings = settings || {};
		} catch (e) {}

		switch (field.type) {
			case 'Groups':
			case 'Assets':
			case 'Entries':
			case 'Categories':
			case 'Users':
				single = settings.limit == 1;
				return `row.${field.handle} = relations.filter(rel => rel.key === '${field.handle}').map(rel => rel.value)${single ? `.shift()` : ``};`;

			case 'Matrix':
				single = settings.maxBlocks == 1;
				return `row.${field.handle} = relations.filter(rel => rel.key === '${field.handle}').map(rel => rel.value)${single ? `.shift()` : ``};`;

			case 'SuperTable':
				single = settings.maxRows == 1;
				return `row.${field.handle} = relations.filter(rel => rel.key === '${field.handle}').map(rel => rel.value)${single ? `.shift()` : ``};`;

			// case 'Folders':
			
			// TODO Tags
			// TODO Table

			default:
				throw new Error(`Type ${field.type} is not a relation.`);
		}
	}

	let groupFields = [
		{handle: 'id', column: 'g.id', type: 'ID', name: 'ID'},
		{handle: 'handle', column: 'g.handle', type: 'PlainText', required: true, name: 'Handle'},
		{handle: 'name', column: 'g.name', type: 'PlainText', required: true, name: 'Name'},
		{handle: 'dateCreated', column: 'g.dateCreated', type: 'Date', name: 'Created date'},
		{handle: 'dateUpdated', column: 'g.dateUpdated', type: 'Date', name: 'Updated date'}
	];
	models.push(`UserGroup`);
	outputModels.push(`class UserGroup extends Model {
	static get schema () {
		return {
			${groupFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, UserGroup, {
	defaultLocale: locale,
	propertyMap: {
		${groupFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${groupFields.map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_usergroups AS g
				\${(where ? \`WHERE \${where}\` : \`\`)}
				\${(order ? \`ORDER BY \${order}\` : \`\`)}
				\${(limit ? \`LIMIT \${limit}\` : \`\`)}
				\${(skip ? \`OFFSET \${skip}\` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				return resolve(rows);
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE g FROM craft_usergroups AS g WHERE g.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				UPDATE craft_usergroups AS g
				SET ${groupFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, g.dateUpdated = NOW()
				WHERE u.id = \${data.id}
			\`, [${groupFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')}], (err) => {
				if (err) return reject(err);
				return resolve(data)
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(
				\`INSERT INTO craft_usergroups (name, handle, dateCreated, dateUpdated, uid) VALUES (?, ?, NOW(), NOW(), ?)\`,
				[data.name, data.handle, uuid4()],
				(err, result) => {
					if (err) return reject(err);
					return resolve(result.insertId);
				}
			);
		});
	}
})`);

	let userLayoutId = layouts.filter(l => l.type === 'User')[0].id;
	let userFields = [
		{handle: 'id', column: 'u.id', type: 'ID', name: 'ID'},
		{handle: 'username', column: 'u.username', type: 'PlainText', required: true, name: 'Username'},
		{handle: 'firstName', column: 'u.firstName', type: 'PlainText', name: 'First name'},
		{handle: 'lastName', column: 'u.lastName', type: 'PlainText', name: 'Last name'},
		{handle: 'email', column: 'u.email', type: 'PlainText', required: true, name: 'Email'},
		{handle: 'preferredLocale', column: 'u.preferredLocale', type: 'PlainText', name: 'Preferred locale'},
		{handle: 'groups', column: 'g.id', type: 'Groups', name: 'Groups', settings: { limit: "" }},
		{handle: 'dateCreated', column: 'u.dateCreated', type: 'Date', name: 'Created date'},
		{handle: 'dateUpdated', column: 'u.dateUpdated', type: 'Date', name: 'Updated date'}
	];
	userFields.push.apply(userFields, layoutFields.filter(lf => lf.layoutId == userLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

	models.push(`User`);
	outputModels.push(`class User extends Model {
	static get schema () {
		return {
			${userFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, User, {
	defaultLocale: locale,
	propertyMap: {
		${userFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${userFields.filter(f => fieldToType(f).relation === null).map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_users AS u
				LEFT JOIN craft_usergroups_users AS g ON g.userId = u.id
				LEFT JOIN craft_content AS c ON c.elementId = u.id AND c.locale = "\${locale}"
				\${(where ? \`WHERE \${where}\` : \`\`)}
				GROUP BY u.id
				\${(order ? \`ORDER BY \${order}\` : \`\`)}
				\${(limit ? \`LIMIT \${limit}\` : \`\`)}
				\${(skip ? \`OFFSET \${skip}\` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${userFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'groups').length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${userFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'groups').map(f => fieldToRelationSelect(f)).concat([`SELECT userId AS "id", "groups" AS "key", groupId AS "value" FROM craft_usergroups_users WHERE userId IN (\${rowIds.join(', ')})`]).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${userFields.filter(f => fieldToType(f).relation !== null).map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.getConnection((err, conn) => {
				const release = () => {
						conn.release();
						return reject(err);
					};
				if (err) return release(err);

				conn.beginTransaction(err => {
					if (err) return release(err);

					const sql = [];
					const values = [];

					sql.push(\`UPDATE craft_users AS u LEFT JOIN craft_content AS c ON c.elementId = u.id AND c.locale = "\${locale}" SET ${userFields.filter(f => fieldToType(f).relation === null && f.handle !== 'id').map(f => `${f.column} = ?`).join(", ")}, u.dateUpdated = NOW(), c.dateUpdated = NOW() WHERE u.id = \${data.id}\`);
					values.push(${userFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

					sql.push(\`DELETE g FROM craft_usergroups_users AS g WHERE userid = ?\`);
					values.push(data.id);

					if (data.groups && isArray(data.groups) && data.groups.length > 0) {
						sql.push(\`INSERT INTO craft_usergroups_users (groupId, userId, dateCreated, dateUpdated, uid) VALUES (\${data.groups.map(v => \`?, ?, NOW(), NOW(), ?\`).join('), (')})\`);
						data.groups.forEach((v, i) => {
							values.push(v, data.id, uuid4());
						});
					}

					${userFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'groups').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

					conn.query(sql.join(';'), values, (err, result) => {
						if (err) {
							return conn.rollback(() => {
								return release(err);
							});
						}
						return conn.commit(err => {
							if (err) return conn.rollback(() => {
								return release(err);
							});
							conn.release();
							return resolve(data);
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.getConnection((err, conn) => {
				if (err) return reject(err);

				conn.beginTransaction(err => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.query(
						\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
						['User', 1, 0, uuid4()],
						(err, result) => {
							if (err) return release(err);
							const id = result.insertId;
							data.id = id;

							const sql = [];
							const values = [];

							sql.push(\`INSERT INTO craft_users (id, username, firstName, lastName, email, preferredLocale, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW(), ?)\`);
							values.push(id, data.username, data.firstName, data.lastName, data.email, data.preferredLocale, uuid4());

							${locales.map(({ locale }) => {
								return `sql.push(\`INSERT INTO craft_content (elementId, locale, title, dateCreated, dateUpdated, uid${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", "", NOW(), NOW(), ?${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
							values.push(id, uuid4()${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${userFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});`;
							}).join("\n\t\t\t\t\t\t\t")}

							if (data.groups && isArray(data.groups) && data.groups.length > 0) {
								sql.push(\`INSERT INTO craft_usergroups_users (groupId, userId, dateCreated, dateUpdated, uid) VALUES (\${data.groups.map(v => \`?, ?, NOW(), NOW(), ?\`).join('), (')})\`);
								data.groups.forEach((v, i) => {
									values.push(v, data.id, uuid4());
								});
							}

							${userFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'groups').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

							conn.query(sql.join(';'), values, (err, result) => {
								if (err) {
									return conn.rollback(() => {
										return release(err);
									});
								}
								return conn.commit(err => {
									if (err) return conn.rollback(() => {
										return release(err);
									});
									conn.release();
									return resolve(id);
								});
							});
						}
					);
				});
			});
		});
	}
})`);

	// globals.forEach(global => {
	// 	let globalFields = layoutFields.filter(lf => lf.layoutId == global.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]);
	// 	console.log(`Global ${global.handle}`, globalFields.length);
	// });

	let sectionHandles = [];

	sections.forEach(section => {
		let sectionTypes = types.filter(t => t.sectionId == section.id).map(type => {
			let typeFields = [
				{handle: 'id', column: 'el.id', type: 'ID', name: 'ID'},
				{handle: 'slug', column: 'eli.slug', type: 'PlainText', name: 'Slug'},
				{handle: 'title', column: 'c.title', type: 'PlainText', name: 'Title'},
				{handle: 'author', column: 'e.authorId', type: 'Users', name: 'Author', settings: { limit: 1, source: '*' }},
				{handle: 'postDate', column: 'e.postDate', type: 'Date', name: 'Publish date'},
				{handle: 'expiryDate', column: 'e.expiryDate', type: 'Date', name: 'Expire date'},
				{handle: 'enabled', column: 'el.enabled', type: 'Lightswitch', name: 'Enabled'},
				{handle: 'archived', column: 'el.archived', type: 'Lightswitch', name: 'Archived'},
				{handle: 'dateCreated', column: 'el.dateCreated', type: 'Date', name: 'Created date'},
				{handle: 'dateUpdated', column: 'el.dateUpdated', type: 'Date', name: 'Updated date'}
			];
			typeFields.push.apply(typeFields, layoutFields.filter(lf => lf.layoutId == type.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));
			return Object.assign({}, type, { fields: typeFields });
		});

		const sectionHandle = section.handle[0].toUpperCase() + section.handle.substr(1);

		const typeHandles = [];

		sectionTypes.forEach(type => {
			const typeHandle = sectionTypes.length == 1 ? sectionHandle : sectionHandle + type.handle[0].toUpperCase() + type.handle.substr(1);
			sectionHandles.push(`Entry${typeHandle}`);
			typeHandles.push(`Entry${typeHandle}`);
			models.push(`Entry${typeHandle}`);
			outputModels.push(`class Entry${typeHandle} extends Model {
	static get schema () {
		return {
			${type.fields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
			outputRecords.push(`domain.registerRecord(adapter, Entry${typeHandle}, {
	defaultLocale: locale,
	propertyMap: {
		${type.fields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${type.fields.filter(f => fieldToType(f).relation === null).map(f => `${f.column} AS "${f.handle}"`).join(", ")}, e.authorId AS "author"
				FROM craft_elements AS el
				LEFT JOIN craft_entries AS e ON e.id = el.id
				LEFT JOIN craft_elements_i18n AS eli ON eli.elementId = e.id AND eli.locale = "\${locale}"
				LEFT JOIN craft_content AS c ON c.elementId = el.id AND c.locale = "\${locale}"
				WHERE e.sectionId = ${section.id} AND e.typeId = ${type.id} \${where ? \`AND (\${where}) \` : \`\`}
				GROUP BY el.id
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${type.fields.filter(f => fieldToType(f).relation !== null && f.handle !== 'author').length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${type.fields.filter(f => fieldToType(f).relation !== null && f.handle !== 'author').map(f => fieldToRelationSelect(f)).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${type.fields.filter(f => fieldToType(f).relation !== null && f.handle !== 'author').map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						const sql = [];
						const values = [];

						sql.push(\`
							UPDATE craft_elements AS el
							LEFT JOIN craft_entries AS e ON e.id = el.id
							LEFT JOIN craft_elements_i18n AS eli ON eli.elementId = e.id AND eli.locale = "\${locale}"
							LEFT JOIN craft_content AS c ON c.elementId = el.id AND c.locale = "\${locale}"
							SET ${type.fields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, el.dateUpdated = NOW(), e.dateUpdated = NOW(), eli.dateUpdated = NOW(), c.dateUpdated = NOW()
							WHERE el.id = \${data.id}
						\`);
						values.push(${type.fields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

						${type.fields.filter(f => fieldToType(f).relation !== null && f.handle !== 'author').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

						conn.query(sql.join(';'), values, (err, result) => {
							if (err) {
								return conn.rollback(() => {
									return release(err);
								});
							}
							return conn.commit(err => {
								if (err) return conn.rollback(() => {
									return release(err);
								});
								conn.release();
								return resolve(data);
							});
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						conn.query(
							\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
							['Entry', 1, 0, uuid4()],
							(err, result) => {
								if (err) return release(err);
								const id = result.insertId;
								data.id = id;

								const sql = [];
								const values = [];

								sql.push(\`INSERT INTO craft_entries (id, sectionId, typeId, authorId, postDate, expiryDate, dateCreated, dateUpdated, uid) VALUES (?, ${section.id}, ${type.id}, ?, ?, ?, NOW(), NOW(), ?)\`);
								values.push(data.id, data.author, data.postDate, data.expiryDate, uuid4());

								${locales.map(({ locale }) => {
									return `
									sql.push(\`INSERT INTO craft_elements_i18n (elementId, locale, slug, uri, enabled, dateCreated, dateUpdated, uid) VALUES (?, "${locale}", ?, ?, 1, NOW(), NOW(), ?)\`);
									values.push(data.id, "", "", uuid4()); // TODO slug & uri field
									sql.push(\`INSERT INTO craft_content (elementId, locale, dateCreated, dateUpdated, uid${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", NOW(), NOW(), ?${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
									values.push(id, uuid4()${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});
									`;
								}).join("\n\t\t\t\t\t\t\t")}

								${type.fields.filter(f => fieldToType(f).relation !== null && f.handle !== 'author').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

								conn.query(sql.join(';'), values, (err, result) => {
									if (err) {
										return conn.rollback(() => {
											return release(err);
										});
									}
									return conn.commit(err => {
										if (err) return conn.rollback(() => {
											return release(err);
										});
										conn.release();
										return resolve(data);
									});
								});
							}
						);
					});
				});
			});
		});
	}
})`);
		});

		if (typeHandles.length > 1) {
			models.push(`Entry${sectionHandle}`);
			outputModels.push(`class Entry${sectionHandle} extends UnionModel {
	static get models () {
		return [${typeHandles.join(', ')}];
	}
}

`);
			outputRecords.push(`domain.registerRecord(adapter, Entry${sectionHandle}, {})`);
		}
	});

	models.push(`Entry`);
	outputModels.push(`class Entry extends UnionModel {
	static get models () {
		return [${sectionHandles.join(', ')}];
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, Entry, {})`);

	const categoryHandles = [];

	categories.forEach(category => {
		let categoryFields = [
			{handle: 'id', column: 'el.id', type: 'ID', name: 'ID'},
			{handle: 'title', column: 'c.title', type: 'PlainText', name: 'Title'},
			{handle: 'dateCreated', column: 'ca.dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', column: 'ca.dateUpdated', type: 'Date', name: 'Updated date'}
		];
		categoryFields.push.apply(categoryFields, layoutFields.filter(lf => lf.layoutId == category.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

		const handle = category.handle[0].toUpperCase() + category.handle.substr(1);
		models.push(`Category${handle}`);
		categoryHandles.push(`Category${handle}`);
		outputModels.push(`class Category${handle} extends Model {
	static get schema () {
		return {
			${categoryFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
		outputRecords.push(`domain.registerRecord(adapter, Category${handle}, {
	defaultLocale: locale,
	propertyMap: {
		${categoryFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${categoryFields.filter(f => fieldToType(f).relation === null).map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_elements AS el
				LEFT JOIN craft_categories AS ca ON ca.id = el.id
				LEFT JOIN craft_elements_i18n AS eli ON eli.elementId = el.id AND eli.locale = "\${locale}"
				LEFT JOIN craft_content AS c ON c.elementId = el.id AND c.locale = "\${locale}"
				WHERE ca.groupId = ${category.id} \${where ? \`AND (\${where}) \` : \`\`}
				GROUP BY el.id
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${categoryFields.filter(f => fieldToType(f).relation !== null).length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${categoryFields.filter(f => fieldToType(f).relation !== null).map(f => fieldToRelationSelect(f)).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${categoryFields.filter(f => fieldToType(f).relation !== null).map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						const sql = [];
						const values = [];

						sql.push(\`
							UPDATE craft_elements AS el
							LEFT JOIN craft_categories AS ca ON ca.id = el.id
							LEFT JOIN craft_elements_i18n AS eli ON eli.elementId = e.id AND eli.locale = "\${locale}"
							LEFT JOIN craft_content AS c ON c.elementId = el.id AND c.locale = "\${locale}"
							SET ${categoryFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, el.dateUpdated = NOW(), ca.dateUpdated = NOW(), eli.dateUpdated = NOW(), c.dateUpdated = NOW()
							WHERE el.id = \${data.id}
						\`);
						values.push(${categoryFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

						${categoryFields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

						conn.query(sql.join(';'), values, (err, result) => {
							if (err) {
								return conn.rollback(() => {
									return release(err);
								});
							}
							return conn.commit(err => {
								if (err) return conn.rollback(() => {
									return release(err);
								});
								conn.release();
								return resolve(data);
							});
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						conn.query(
							\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
							['Category', 1, 0, uuid4()],
							(err, result) => {
								if (err) return release(err);
								const id = result.insertId;
								data.id = id;

								const sql = [];
								const values = [];

								sql.push(\`INSERT INTO craft_entries (id, groupId, dateCreated, dateUpdated, uid) VALUES (?, ${category.id}, NOW(), NOW(), ?)\`);
								values.push(data.id, uuid4());

								${locales.map(({ locale }) => {
									return `
									sql.push(\`INSERT INTO craft_elements_i18n (elementId, locale, slug, uri, enabled, dateCreated, dateUpdated, uid) VALUES (?, "${locale}", ?, ?, 1, NOW(), NOW(), ?)\`);
									values.push(data.id, "", "", uuid4()); // TODO slug & uri field
									sql.push(\`INSERT INTO craft_content (elementId, locale, dateCreated, dateUpdated, uid${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", NOW(), NOW(), ?${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
									values.push(id, uuid4()${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${categoryFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});
									`;
								}).join("\n\t\t\t\t\t\t\t")}

								${categoryFields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

								conn.query(sql.join(';'), values, (err, result) => {
									if (err) {
										return conn.rollback(() => {
											return release(err);
										});
									}
									return conn.commit(err => {
										if (err) return conn.rollback(() => {
											return release(err);
										});
										conn.release();
										return resolve(data);
									});
								});
							}
						);
					});
				});
			});
		});
	}
})`);
	});

	models.push(`Category`);
	outputModels.push(`class Category extends UnionModel {
	static get models () {
		return [${categoryHandles.join(', ')}];
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, Category, {})`);

	let folderFields = [
		{handle: 'id', column: 'f.id', type: 'ID', name: 'ID'},
		{handle: 'name', column: 'f.name', type: 'PlainText', name: 'Name'},
		{handle: 'parent', column: 'f.parentId', type: 'AssetFolders', name: 'Parent', settings: { limit: 1 }},
		{handle: 'dateCreated', column: 'f.dateCreated', type: 'Date', name: 'Created date'},
		{handle: 'dateUpdated', column: 'f.dateUpdated', type: 'Date', name: 'Updated date'}
	];
	models.push(`AssetFolder`);
	outputModels.push(`class AssetFolder extends Model {
	static get schema () {
		return {
			${folderFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, AssetFolder, {
	defaultLocale: locale,
	propertyMap: {
		${folderFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${folderFields.map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_assetfolders AS f
				\${(where ? \`WHERE \${where}\` : \`\`)}
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				return resolve(rows);
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE f FFROM craft_assetfolders AS f WHERE f.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.query(
					\`
						UPDATE craft_assetfolders AS f
						SET ${folderFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, f.dateUpdated = NOW()
						WHERE f.id = \${data.id}
					\`,
					[${folderFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')}],
					(err, results) => {
						if (err) return reject(err);
						return resolve(data);
					}
				);
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.query(
					\`INSERT INTO craft_assetfolders (name, parent, dateCreated, dateUpdated, uid) VALUES (?, ?, NOW(), NOW(), ?)\`,
					[data.name, data.parent, uuid4()],
					(err, result) => {
						if (err) return reject(err);
						return resolve(result.insertId);
					}
				);
			});
		});
	}
})`);

	const assetHandles = [];
	assets.forEach(asset => {
		let assetFields = [
			{handle: 'id', column: 'a.id', type: 'ID', name: 'ID'},
			{handle: 'filename', column: 'a.filename', type: 'PlainText', name: 'Filename'},
			{handle: 'folder', column: 'a.folderId', type: 'AssetFolders', name: 'Folder', settings: { limit: 1 }},
			{handle: 'kind', column: 'a.kind', type: 'PlainText', name: 'Kind'},
			{handle: 'size', column: 'a.size', type: 'Number', name: 'Size'},
			{handle: 'dateModified', column: 'a.dateModified', type: 'Date', name: 'Modified date'},
			{handle: 'dateCreated', column: 'a.dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', column: 'a.dateUpdated', type: 'Date', name: 'Updated date'}
		];
		assetFields.push.apply(assetFields, layoutFields.filter(lf => lf.layoutId == asset.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));
		
		const handle = asset.handle[0].toUpperCase() + asset.handle.substr(1);
		assetHandles.push(`Asset${handle}`);
		models.push(`Asset${handle}`);
		outputModels.push(`class Asset${handle} extends Model {
	static get schema () {
		return {
			${assetFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
		outputRecords.push(`domain.registerRecord(adapter, Asset${handle}, {
	defaultLocale: locale,
	propertyMap: {
		${assetFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${assetFields.filter(f => fieldToType(f).relation === null || f.handle === 'folder').map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_assetfiles AS a
				LEFT JOIN craft_content AS c ON c.elementId = a.id AND c.locale = "\${locale}"
				WHERE a.sourceId = ${asset.id} \${where ? \`AND (\${where}) \` : \`\`}
				GROUP BY a.id
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${assetFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'folder').length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${assetFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'folder').map(f => fieldToRelationSelect(f)).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${assetFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'folder').map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						const sql = [];
						const values = [];

						sql.push(\`
							UPDATE craft_assetfiles AS a
							LEFT JOIN craft_content AS c ON c.elementId = a.id AND c.locale = "\${locale}"
							SET ${assetFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, a.dateUpdated = NOW(), c.dateUpdated = NOW()
							WHERE a.id = \${data.id}
						\`);
						values.push(${assetFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

						${assetFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'folder').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

						conn.query(sql.join(';'), values, (err, result) => {
							if (err) {
								return conn.rollback(() => {
									return release(err);
								});
							}
							return conn.commit(err => {
								if (err) return conn.rollback(() => {
									return release(err);
								});
								conn.release();
								return resolve(data);
							});
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						conn.query(
							\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
							['Asset', 1, 0, uuid4()],
							(err, result) => {
								if (err) return release(err);
								const id = result.insertId;
								data.id = id;

								const sql = [];
								const values = [];

								sql.push(\`INSERT INTO craft_assetfiles (id, sourceId, folderId, filename, kind, width, height, size, dateModified, dateCreated, dateUpdated, uid) VALUES (?, NULL, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?)\`);
								values.push(data.id, data.parent, data.filename, data.kind, data.width, data.height, data.size, data.dateModified, uuid4());

								${locales.map(({ locale }) => {
									return `
									sql.push(\`INSERT INTO craft_elements_i18n (elementId, locale, slug, uri, enabled, dateCreated, dateUpdated, uid) VALUES (?, "${locale}", ?, ?, 1, NOW(), NOW(), ?)\`);
									values.push(data.id, "", "", uuid4()); // TODO slug & uri field
									sql.push(\`INSERT INTO craft_content (elementId, locale, dateCreated, dateUpdated, uid${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", NOW(), NOW(), ?${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
									values.push(id, uuid4()${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${assetFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});
									`;
								}).join("\n\t\t\t\t\t\t\t")}

								${assetFields.filter(f => fieldToType(f).relation !== null && f.handle !== 'folder').map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

								conn.query(sql.join(';'), values, (err, result) => {
									if (err) {
										return conn.rollback(() => {
											return release(err);
										});
									}
									return conn.commit(err => {
										if (err) return conn.rollback(() => {
											return release(err);
										});
										conn.release();
										return resolve(data);
									});
								});
							}
						);
					});
				});
			});
		});
	}
})`);
	});

	models.push(`Asset`);
	outputModels.push(`class Asset extends UnionModel {
	static get models () {
		return [${assetHandles.join(', ')}];
	}
}

`);
	outputRecords.push(`domain.registerRecord(adapter, Asset, {})`);

	fields.filter(f => f.type == 'Matrix').forEach(field => {
		let types = matrices.filter(m => m.fieldId == field.id).map(matrix => {
			let matrixFields = [
				{handle: 'id', column: 'b.id', type: 'ID', name: 'ID'},
				{handle: 'dateCreated', column: 'b.dateCreated', type: 'Date', name: 'Created date'},
				{handle: 'dateUpdated', column: 'b.dateUpdated', type: 'Date', name: 'Updated date'}
			];
			matrixFields.push.apply(
				matrixFields,
				layoutFields
					.filter(lf => lf.layoutId == matrix.fieldLayoutId)
					.map(lf => fields.filter(f => lf.fieldId == f.id)[0])
					.map(f => {
						f.column = f.column.replace('c.field_', `c.field_${matrix.handle}_`);
						return f;
					})
			);
			return Object.assign({}, matrix, { fields: matrixFields });
		});

		const matrixHandle = field.handle[0].toUpperCase() + field.handle.substr(1);

		const typeHandles = [];

		types.forEach(type => {
			const typeHandle = types.length == 1 ? matrixHandle : matrixHandle + type.handle[0].toUpperCase() + type.handle.substr(1);
			typeHandles.push(`Matrix${typeHandle}`);
			models.push(`Matrix${typeHandle}`);
			outputModels.push(`class Matrix${typeHandle} extends Model {
	static get schema () {
		return {
			${type.fields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
			outputRecords.push(`domain.registerRecord(adapter, Matrix${typeHandle}, {
	defaultLocale: locale,
	propertyMap: {
		${type.fields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${type.fields.filter(f => fieldToType(f).relation === null).map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_matrixblocks AS b
				LEFT JOIN craft_matrixcontent_${field.handle.toLowerCase()} AS c ON c.elementId = b.id AND c.locale = "\${locale}"
				WHERE b.fieldId = ${field.id} AND b.typeId = ${type.id} \${where ? \`AND (\${where}) \` : \`\`}
				GROUP BY b.id
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${type.fields.filter(f => fieldToType(f).relation !== null).length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${type.fields.filter(f => fieldToType(f).relation !== null).map(f => fieldToRelationSelect(f)).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${type.fields.filter(f => fieldToType(f).relation !== null).map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						const sql = [];
						const values = [];

						sql.push(\`
							UPDATE craft_matrixblocks AS b
							LEFT JOIN craft_matrixcontent_${field.handle.toLowerCase()} AS c ON c.elementId = b.id AND c.locale = "\${locale}"
							SET ${type.fields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, b.dateUpdated = NOW(), c.dateUpdated = NOW()
							WHERE b.id = \${data.id}
						\`);
						values.push(${type.fields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

						${type.fields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

						conn.query(sql.join(';'), values, (err, result) => {
							if (err) {
								return conn.rollback(() => {
									return release(err);
								});
							}
							return conn.commit(err => {
								if (err) return conn.rollback(() => {
									return release(err);
								});
								conn.release();
								return resolve(data);
							});
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						conn.query(
							\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
							['MatrixBlock', 1, 0, uuid4()],
							(err, result) => {
								if (err) return release(err);
								const id = result.insertId;
								data.id = id;

								const sql = [];
								const values = [];

								sql.push(\`INSERT INTO craft_matrixblocks (id, ownerId, fieldId, typeId, sortOrder, ownerLocale, dateCreated, dateUpdated, uid) VALUES (?, NULL, ${field.id}, ${type.id}, 0, NULL, NOW(), NOW(), ?)\`);
								values.push(data.id, uuid4());

								${locales.map(({ locale }) => {
									return `
									sql.push(\`INSERT INTO craft_elements_i18n (elementId, locale, slug, uri, enabled, dateCreated, dateUpdated, uid) VALUES (?, "${locale}", ?, ?, 1, NOW(), NOW(), ?)\`);
									values.push(data.id, "", "", uuid4());
									sql.push(\`INSERT INTO craft_matrixcontent_${field.handle.toLowerCase()} (elementId, locale, dateCreated, dateUpdated, uid${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", NOW(), NOW(), ?${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
									values.push(id, uuid4()${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${type.fields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});
									`;
								}).join("\n\t\t\t\t\t\t\t")}

								${type.fields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

								conn.query(sql.join(';'), values, (err, result) => {
									if (err) {
										return conn.rollback(() => {
											return release(err);
										});
									}
									return conn.commit(err => {
										if (err) return conn.rollback(() => {
											return release(err);
										});
										conn.release();
										return resolve(data);
									});
								});
							}
						);
					});
				});
			});
		});
	}
})`);
		});

		if (typeHandles.length > 1) {
			models.push(`Matrix${matrixHandle}`);
			outputModels.push(`class Matrix${matrixHandle} extends UnionModel {
	static get models () {
		return [${typeHandles.join(', ')}];
	}
}

`);
			outputRecords.push(`domain.registerRecord(adapter, Matrix${matrixHandle}, {})`);
		}
	});

	fields.filter(f => f.type == 'SuperTable').forEach(field => {

		let tableFields = [
			{handle: 'id', column: 'b.id', type: 'ID', name: 'ID'},
			{handle: 'dateCreated', column: 'b.dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', column: 'b.dateUpdated', type: 'Date', name: 'Updated date'}
		];

		let layoutId = superTables.filter(st => st.fieldId == field.id)[0].fieldLayoutId;
		tableFields.push.apply(tableFields, layoutFields.filter(lf => lf.layoutId == layoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

		const tableHandle = field.handle[0].toUpperCase() + field.handle.substr(1);
		models.push(`SuperTable${tableHandle}`);
		outputModels.push(`class SuperTable${tableHandle} extends Model {
	static get schema () {
		return {
			${tableFields.map(field => fieldToDefinition(field)).join(',\n\t\t\t')}
		}
	}
}

`);
		outputRecords.push(`domain.registerRecord(adapter, SuperTable${tableHandle}, {
	defaultLocale: locale,
	propertyMap: {
		${tableFields.map(f => `'${f.handle}': '${f.column}'`).join(",\n\t\t")}
	},
	onSelect: (db, where, order, { limit, skip, locale }, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`
				SELECT ${tableFields.filter(f => fieldToType(f).relation === null).map(f => `${f.column} AS "${f.handle}"`).join(", ")}
				FROM craft_supertableblocks AS b
				LEFT JOIN craft_supertablecontent_${field.handle.toLowerCase()} AS c ON c.elementId = b.id AND c.locale = "\${locale}"
				WHERE b.fieldId = ${field.id} \${where ? \`AND (\${where}) \` : \`\`}
				GROUP BY b.id
				\${(order ? \`ORDER BY \${order} \` : \`\`)}
				\${(limit ? \`LIMIT \${limit} \` : \`\`)}
				\${(skip ? \`OFFSET \${skip} \` : \`\`)}
			\`, (err, rows) => {
				if (err) return reject(err);
				${tableFields.filter(f => fieldToType(f).relation !== null).length > 0 ? `if (rows.length > 0) {
					const rowIds = rows.map(row => row.id);
					db.query(\`
						(${tableFields.filter(f => fieldToType(f).relation !== null).map(f => fieldToRelationSelect(f)).join(")\n\t\t\t\t\t\tUNION\n\t\t\t\t\t\t(")})
					\`, (err, relations) => {
						if (err) return reject(err);

						rows.forEach(row => {
							${tableFields.filter(f => fieldToType(f).relation !== null).map(field => relationToProperty(field)).join("\n\t\t\t\t\t\t\t")}
						});

						return resolve(rows);
					});
				} else { return resolve(rows); }` : `return resolve(rows);`}
			});
		});
	},
	onDelete: (db, ids, options, configs) => {
		return new Promise((resolve, reject) => {
			db.query(\`DELETE el FFROM craft_elements AS el WHERE el.id IN (\${ids.join(', ')})\`, (err) => {
				if (err) return reject(err);
				return resolve(ids);
			})
		});
	},
	onUpdate: (db, data, { locale }, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						const sql = [];
						const values = [];

						sql.push(\`
							UPDATE craft_supertableblocks AS b
							LEFT JOIN craft_supertablecontent_${field.handle.toLowerCase()} AS c ON c.elementId = b.id AND c.locale = "\${locale}"
							SET ${tableFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `${f.column} = ?`).join(", ")}, b.dateUpdated = NOW(), c.dateUpdated = NOW()
							WHERE b.id = \${data.id}
						\`);
						values.push(${tableFields.filter(f => fieldToType(f).relation === null && ['id', 'dateCreated', 'dateUpdated'].indexOf(f.handle) == -1).map(f => `data.${f.handle}`).join(', ')});

						${tableFields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

						conn.query(sql.join(';'), values, (err, result) => {
							if (err) {
								return conn.rollback(() => {
									return release(err);
								});
							}
							return conn.commit(err => {
								if (err) return conn.rollback(() => {
									return release(err);
								});
								conn.release();
								return resolve(data);
							});
						});
					});
				});
			});
		});
	},
	onCreate: (db, data, options, configs) => {
		return new Promise((resolve, reject) => {
			return new Promise((resolve, reject) => {
				db.getConnection((err, conn) => {
					const release = () => {
						conn.release();
						return reject(err);
					};
					if (err) return release(err);

					conn.beginTransaction(err => {
						if (err) return release(err);

						conn.query(
							\`INSERT INTO craft_elements (type, enabled, archived, dateCreated, dateUpdated, uid) VALUES (?, ?, ?, NOW(), NOW(), ?)\`,
							['MatrixBlock', 1, 0, uuid4()],
							(err, result) => {
								if (err) return release(err);
								const id = result.insertId;
								data.id = id;

								const sql = [];
								const values = [];

								sql.push(\`INSERT INTO craft_supertableblocks (id, ownerId, fieldId, typeId, sortOrder, ownerLocale, dateCreated, dateUpdated, uid) VALUES (?, NULL, ${field.id}, NULL, 0, NULL, NOW(), NOW(), ?)\`);
								values.push(data.id, uuid4());

								${locales.map(({ locale }) => {
									return `
									sql.push(\`INSERT INTO craft_elements_i18n (elementId, locale, slug, uri, enabled, dateCreated, dateUpdated, uid) VALUES (?, "${locale}", ?, ?, 1, NOW(), NOW(), ?)\`);
									values.push(data.id, "", "", uuid4());
									sql.push(\`INSERT INTO craft_supertablecontent_${field.handle.toLowerCase()} (elementId, locale, dateCreated, dateUpdated, uid${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => f.column.substr(2)).join(', ')}` : ``}) VALUES (?, "${locale}", NOW(), NOW(), ?${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => '?').join(', ')}` : ``})\`);
									values.push(id, uuid4()${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).length > 0 ? `, ${tableFields.filter(f => f.column[0] === 'c' && fieldToType(f).relation === null).map(f => `data.${f.handle}`).join(', ')}` : ``});
									`;
								}).join("\n\t\t\t\t\t\t\t")}

								${tableFields.filter(f => fieldToType(f).relation !== null).map(field => fieldToRelationInsert(field)).join("\n\t\t\t\t\t")}

								conn.query(sql.join(';'), values, (err, result) => {
									if (err) {
										return conn.rollback(() => {
											return release(err);
										});
									}
									return conn.commit(err => {
										if (err) return conn.rollback(() => {
											return release(err);
										});
										conn.release();
										return resolve(data);
									});
								});
							}
						);
					});
				});
			});
		});
	}
})`);
	});

	process.stdout.write(`"use strict"

const { Model, UnionModel, Type, Schema } = require('konstellio-orm');
const { isArray } = require('util');

// UUID v4 generator (RFC4122 compliant)
function uuid4 () {
	let uuid = "", i, random;
	for (i = 0; i < 32; ++i) {
		random = Math.random() * 16 | 0;

		if (i == 8 || i == 12 || i == 16 || i == 20) {
			uuid += "-"
		}
		uuid += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
	}
	return uuid;
}

${outputModels.join('')}

function createRecords (domain, adapter, locale) {
	return Promise.all([
		${outputRecords.join(",\n")}
	]).then(([${models.join(', ')}]) => {
		return {
			${models.join(", ")}
		};
	});
}

module.exports = {
	models: { ${models.join(', ')} },
	createRecords: createRecords
};`);

})
.catch(err => {
	console.error(err);
})
.then(() => {
	db.end();
})