#!/usr/bin/env node
"use strict";

const help = require('optimist')
.usage('Usage: $0 --host [host] --port [port] --user [user] --pass [pass] --db [db]')
.demand(['host', 'user', 'db'])
.describe('host', 'The hostname to the database you are connecting to')
.describe('port', 'The port number to connect to')
.describe('user', 'The MySQL user to authenticate as')
.describe('pass', 'The password for the MySQL user')
.describe('db', 'Name of the database to use for this db')

const argv = help.argv;
const MySQL = require('mysql');
const Promise = require('bluebird');

const db = MySQL.createPool({
	connectionLimit: 10,
	host: argv.host,
	port: argv.port || 3306,
	user: argv.user,
	password: argv.pass,
	database: argv.db,
	charset: 'utf8'
});

Promise.all([
	new Promise(resolve => {
		db.query('SELECT locale FROM craft_locales ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_globalsets', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, name, handle, type FROM craft_sections', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, sectionId, fieldLayoutId, name, handle, hasTitleField, titleLabel FROM craft_entrytypes ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_categorygroups', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldId, fieldLayoutId, name, handle FROM craft_matrixblocktypes ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldLayoutId, name, handle FROM craft_assetsources ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, type FROM craft_fieldlayouts', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, layoutId, fieldId, required FROM craft_fieldlayoutfields ORDER BY sortOrder', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, name, handle, context, instructions, translatable, type, settings FROM craft_fields', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
	new Promise(resolve => {
		db.query('SELECT id, fieldId, fieldLayoutId FROM craft_supertableblocktypes', (err, rows) => {
			resolve(err ? [] : rows);
		});
	}),
])
.spread((locales, globals, sections, types, categories, matrices, assets, layouts, layoutFields, fields, superTables) => {

	const outputField = (field) => {
		let out = `${field.handle}: { `;
		let type = null;
		let settings = {};

		try {
			settings = typeof field.settings === 'string' ? JSON.parse(field.settings) : field.settings;
			settings = settings || {};
		} catch (e) {}

		switch (field.type) {
			case 'ID':
				type = 'Type.String';
				break;

			case 'Groups':
				try {
					type = settings.limit === "" || settings.limit > 1 ? 'new Type.ListOf(Group)' : 'Group';
				} catch (e) {
					type = 'Group';
				}
				break;

			case 'Users':
				try {
					type = settings.limit === "" || settings.limit > 1 ? 'new Type.ListOf(User)' : 'User';
				}
				catch (e) {
					type = 'User';
				}
				break;

			case 'Entries':
				try {
					// if (settings.sources == '*') {
					// 	type = 'Section';
					// }
					// else {
						
					// }
					type = settings.limit === "" || settings.limit > 1 ? `new Type.ListOf(Section)` : 'Section';
				}
				catch (e) {
					throw new Error(`Could not find entries for "${settings.sources}".`);
				}
				break;

			case 'Categories':
				try {
					let categoryId = settings.source.split(':')[1];
					let category = categories.filter(c => c.id == categoryId)[0];
					type = 'Category' + category.handle[0].toUpperCase() + category.handle.substr(1);
				}
				catch (e) {
					throw new Error(`Could not find category for "${settings.source}".`);
				}
				break;

			case 'Assets':
				try {
					// if (settings.sources == '*') {
					// 	type = 'Asset';
					// }
					// else {

					// }
					type = settings.limit === "" || settings.limit > 1 ? `new Type.ListOf(Asset)` : 'Asset';
				}
				catch (e) {
					throw new Error(`Could not find asset for "${settings.source}".`);
				}
				break;

			case 'Folders':
				type = 'Folder';
				try {
					type = settings.limit == null || settings.limit > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			case 'Matrix':
				type = 'Matrix' + field.handle[0].toUpperCase() + field.handle.substr(1);
				try {
					type = settings.maxBlocks == null || settings.maxBlocks > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			// TODO Tags
			// TODO Table

			case 'SuperTable':
				type = 'SuperTable' + field.handle[0].toUpperCase() + field.handle.substr(1);
				try {
					type = settings.maxRows == null || settings.maxRows > 1 ? `new Type.ListOf(${type})` : type;
				}
				catch (e) {}
				break;

			case 'PlainText':
			case 'RichText':
			case 'Color':
			case 'Dropdown':
			case 'RadioButtons':
			case 'PositionSelect':
				type = 'Type.String';
				break;
			case 'MultiSelect':
				type = 'new Type.ListOf(Type.String)';
				break;
			case 'Lightswitch':
				type = 'Type.Boolean';
				break;
			case 'Number':
				type = 'Type.' + (settings.decimals == 0 ? 'Int' : 'Float');
				break;
			case 'Date':
				type = 'Type.Date';
				break;
			
			default:
				if (settings.columnType && settings.columnType == 'text') {
					type = 'Type.String';
					break;
				}
				throw new Error(`Unknown field type ${field.type}.`);
		}



		if (field.translatable == "1") {
			type = `new Type.Translatable(${type})`;
		}
		
		out += `type: ${type}, `;

		if (field.required) {
			out += `required: true, `;
		}

		if (field.name) {
			out += `label: ${JSON.stringify(field.name)}, `;
		}

		if (field.instructions) {
			out += `instructions: ${JSON.stringify(field.instructions)}, `;
		}

		return `${out} }`;
	};

	process.stdout.write(`"use strict"

const { Model, UnionModel, Type, Schema } = require('konstellio-orm');

`);

	let groupFields = [
		{handle: 'id', type: 'ID', name: 'ID'},
		{handle: 'handle', type: 'PlainText', required: true, name: 'Handle'},
		{handle: 'name', type: 'PlainText', required: true, name: 'Name'},
		{handle: 'dateCreated', type: 'Date', name: 'Created date'},
		{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
	];
	process.stdout.write(`class Group extends Model {
	static get schema () {
		return {
			${groupFields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);

	let userLayoutId = layouts.filter(l => l.type === 'User')[0].id;
	let userFields = [
		{handle: 'id', type: 'ID', name: 'ID'},
		{handle: 'username', type: 'PlainText', required: true, name: 'Username'},
		{handle: 'firstName', type: 'PlainText', name: 'First name'},
		{handle: 'lastName', type: 'PlainText', name: 'Last name'},
		{handle: 'email', type: 'PlainText', required: true, name: 'Email'},
		{handle: 'preferredLocale', type: 'PlainText', name: 'Preferred locale'},
		{handle: 'groups', type: 'Groups', name: 'Groups', settings: { limit: "" }},
		{handle: 'dateCreated', type: 'Date', name: 'Created date'},
		{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
	];
	userFields.push.apply(userFields, layoutFields.filter(lf => lf.layoutId == userLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

	process.stdout.write(`class User extends Model {
	static get schema () {
		return {
			${userFields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);

	// globals.forEach(global => {
	// 	let globalFields = layoutFields.filter(lf => lf.layoutId == global.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]);
	// 	console.log(`Global ${global.handle}`, globalFields.length);
	// });

	sections.forEach(section => {
		let sectionTypes = types.filter(t => t.sectionId == section.id).map(type => {
			let typeFields = [
				{handle: 'id', type: 'ID', name: 'ID'},
				{handle: 'slug', type: 'PlainText', name: 'Slug'},
				{handle: 'title', type: 'PlainText', name: 'Title'},
				{handle: 'author', type: 'Users', name: 'Author', settings: { limit: 1, source: '*' }},
				{handle: 'postDate', type: 'Date', name: 'Publish date'},
				{handle: 'expiryDate', type: 'Date', name: 'Expire date'},
				{handle: 'enabled', type: 'Lightswitch', name: 'Enabled'},
				{handle: 'dateCreated', type: 'Date', name: 'Created date'},
				{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
			];
			typeFields.push.apply(typeFields, layoutFields.filter(lf => lf.layoutId == type.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));
			return Object.assign({}, type, { fields: typeFields });
		});

		const sectionHandle = section.handle[0].toUpperCase() + section.handle.substr(1);

		const typeHandles = [];

		sectionTypes.forEach(type => {
			const typeHandle = sectionTypes.length == 1 ? sectionHandle : sectionHandle + type.handle[0].toUpperCase() + type.handle.substr(1);
			typeHandles.push(`Section${typeHandle}`);
			process.stdout.write(`class Section${typeHandle} extends Model {
	static get schema () {
		return {
			${type.fields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);
		});

		if (typeHandles.length > 1) {
			process.stdout.write(`class Section${sectionHandle} extends UnionModel {
	static get models () {
		return [${typeHandles.join(', ')}];
	}
}

`);
		}
	})

	categories.forEach(category => {
		let categoryFields = [
			{handle: 'id', type: 'ID', name: 'ID'},
			{handle: 'slug', type: 'PlainText', name: 'Slug'},
			{handle: 'title', type: 'PlainText', name: 'Title'},
			{handle: 'dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
		];
		categoryFields.push.apply(categoryFields, layoutFields.filter(lf => lf.layoutId == category.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

		const handle = category.handle[0].toUpperCase() + category.handle.substr(1);
		process.stdout.write(`class Category${handle} extends Model {
	static get schema () {
		return {
			${categoryFields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	});

	const assetHandles = [];

	assets.forEach(asset => {
		let assetFields = [
			{handle: 'id', type: 'ID', name: 'ID'},
			{handle: 'filename', type: 'PlainText', name: 'Filename'},
			{handle: 'folder', type: 'Folders', name: 'Folder', settings: { limit: 1 }},
			{handle: 'kind', type: 'PlainText', name: 'Kind'},
			{handle: 'size', type: 'Number', name: 'Size'},
			{handle: 'dateModified', type: 'Date', name: 'Modified date'},
			{handle: 'dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
		];
		assetFields.push.apply(assetFields, layoutFields.filter(lf => lf.layoutId == asset.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));
		
		const handle = asset.handle[0].toUpperCase() + asset.handle.substr(1);
		assetHandles.push(`Asset${handle}`);
		process.stdout.write(`class Asset${handle} extends Model {
	static get schema () {
		return {
			${assetFields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	});

	if (assetHandles.length > 0) {
			process.stdout.write(`class Asset extends UnionModel {
	static get models () {
		return [${assetHandles.join(', ')}];
	}
}

`);
	}

	fields.filter(f => f.type == 'Matrix').forEach(field => {
		let types = matrices.filter(m => m.fieldId == field.id).map(matrix => {
			let matrixFields = [
				{handle: 'id', type: 'ID', name: 'ID'},
				{handle: 'dateCreated', type: 'Date', name: 'Created date'},
				{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
			];
			matrixFields.push.apply(matrixFields, layoutFields.filter(lf => lf.layoutId == matrix.fieldLayoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));
			return Object.assign({}, matrix, { fields: matrixFields });
		});

		const matrixHandle = field.handle[0].toUpperCase() + field.handle.substr(1);

		const typeHandles = [];

		types.forEach(type => {
			const typeHandle = types.length == 1 ? matrixHandle : matrixHandle + type.handle[0].toUpperCase() + type.handle.substr(1);
			typeHandles.push(`Matrix${typeHandle}`);
			process.stdout.write(`class Matrix${typeHandle} extends Model {
	static get schema () {
		return {
			${type.fields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);
		});

		if (typeHandles.length > 1) {
			process.stdout.write(`class Matrix${matrixHandle} extends UnionModel {
	static get models () {
		return [${typeHandles.join(', ')}];
	}
}

`);
		}
	});

	fields.filter(f => f.type == 'SuperTable').forEach(field => {

		let tableFields = [
			{handle: 'id', type: 'ID', name: 'ID'},
			{handle: 'dateCreated', type: 'Date', name: 'Created date'},
			{handle: 'dateUpdated', type: 'Date', name: 'Updated date'}
		];

		let layoutId = superTables.filter(st => st.fieldId == field.id)[0].fieldLayoutId;
		tableFields.push.apply(tableFields, layoutFields.filter(lf => lf.layoutId == layoutId).map(lf => fields.filter(f => lf.fieldId == f.id)[0]));

		const tableHandle = field.handle[0].toUpperCase() + field.handle.substr(1);

		process.stdout.write(`class SuperTable${tableHandle} extends Model {
	static get schema () {
		return {
			${tableFields.map(field => outputField(field)).join(',\n\t\t\t')}
		}
	}
}

`);
	});

})
.catch(err => {
	console.error(err);
})
.then(() => {
	db.end();
})